// Generated by CoffeeScript 1.10.0
(function() {
  var RssSelector, evaluateGroup, extractGroupCharactor, findGroup, findSimilarNode, likelyStaticAttr,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  $.fn.fingerPrint = function() {
    var classPrint, idPrint;
    classPrint = this[0].className.split(/\s+/g).join(".");
    idPrint = "#" + this[0].id || "";
    return [this[0].tagName, idPrint, classPrint].join("");
  };

  $.fn.pathFingerPrint = function() {
    var parent, prints;
    parent = this[0];
    prints = [];
    while (parent) {
      prints.push($(parent).fingerPrint());
      parent = parent.parentElement;
    }
    return prints.join(" ");
  };

  $.fn.averageLeafWidth = function() {
    var count, node, total;
    node = this[0];
    total = 0;
    count = 0;
    traverse(node, function(item) {
      if (!item.children || item.children.length === 0) {
        total += item.clientWidth;
        return count += 1;
      }
    });
    return count;
  };

  $.fn.maxLeafWidth = function() {
    var max, node;
    max = 0;
    node = this[0];
    traverse(node, function(item) {
      if (!item.children || item.children.length === 0) {
        if (item.offsetWidth > max) {
          return max = item.offsetWidth;
        }
      }
    });
    return max;
  };

  Math.ln = function(a) {
    return Math.log(a) / Math.log(Math.E);
  };

  RssSelector = (function(superClass) {
    extend(RssSelector, superClass);

    function RssSelector() {
      RssSelector.__super__.constructor.call(this);
    }

    RssSelector.prototype.select = function(item, callback) {
      var group, groups, i, index, len, nodes, resultGroups;
      nodes = findSimilarNode(item);
      nodes.push(item);
      groups = findGroup(nodes, item);
      resultGroups = [];
      for (index = i = 0, len = groups.length; i < len; index = ++i) {
        group = groups[index];
        if (indexOf.call(group.children, item) < 0) {
          continue;
        }
        resultGroups.push(group);
      }
      return resultGroups;
    };

    return RssSelector;

  })(Leaf.EventEmitter);

  window.RssSelector = RssSelector;

  likelyStaticAttr = function(attr) {
    if (/[0-9]+/.test(attr)) {
      return false;
    }
    return true;
  };

  $.fn.charactorQuery = function() {
    var classes, elem, query, result;
    elem = this[0];
    result = [];
    while (elem && elem !== document.body.parentElement) {
      query = [elem.tagName || ""];
      if (elem.id && likelyStaticAttr(elem.id)) {
        query.push("#" + elem.id);
      }
      if (elem.className) {
        classes = elem.className.split(/\s+/);
        classes = classes.filter(function(item) {
          return likelyStaticAttr(item);
        });
        query.push.apply(query, classes.map(function(item) {
          return "." + item;
        }));
      }
      result.push(query.join(""));
      elem = elem.parentElement;
    }
    return result.reverse().join(" > ");
  };

  extractGroupCharactor = function(group) {
    var child, childQuery, childrenQueries, containerBrotherCount, containerIndex, containerQuery, containerQueryArr, elem, i, index, item, j, len, len1, ref, resultCharactor, totalContainer;
    resultCharactor = {};
    containerQueryArr = [];
    elem = group.container;
    containerQuery = $(elem).charactorQuery();
    totalContainer = $(containerQuery);
    containerIndex = 0;
    containerBrotherCount = totalContainer.length;
    for (index = i = 0, len = totalContainer.length; i < len; index = ++i) {
      item = totalContainer[index];
      if (item === group.container) {
        containerIndex = index;
        break;
      }
    }
    childrenQueries = [];
    ref = group.children;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      child = ref[j];
      childQuery = $(child).charactorQuery();
      if (indexOf.call(childrenQueries, childQuery) < 0) {
        childrenQueries.push(childQuery);
      }
    }
    resultCharactor.strict = false;
    resultCharactor.Index = containerIndex;
    resultCharactor.containerPath = containerQuery;
    resultCharactor.childrenPathes = childrenQueries || [];
    resultCharactor.url = window.location.toString();
    resultCharactor.name = window.title;
    console.log(resultCharactor);
    console.log(JSON.stringify(resultCharactor));
    console.log(window.btoa(escape(JSON.stringify(resultCharactor))));
    return resultCharactor;
  };

  findSimilarNode = function(node) {
    var another, anotherCharactor, charactor, glipse, i, len, nodes;
    nodes = document.getElementsByTagName("*");
    charactor = $(node).charactor();
    glipse = [];
    for (i = 0, len = nodes.length; i < len; i++) {
      another = nodes[i];
      if (another === node) {
        continue;
      }
      anotherCharactor = $(another).charactor();
      if (anotherCharactor.level === charactor.level && anotherCharactor.type === charactor.type) {
        glipse.push(another);
      }
    }
    return glipse;
  };

  findGroup = function(nodes, sample) {
    var firstNode, group, groups, hasGroup, i, index, j, k, l, len, len1, parent, ref, ref1, ref2, secondNode, targetIndex;
    groups = [];
    for (index = i = 0, ref = nodes.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
      for (targetIndex = j = ref1 = index + 1, ref2 = nodes.length; ref1 <= ref2 ? j < ref2 : j > ref2; targetIndex = ref1 <= ref2 ? ++j : --j) {
        firstNode = nodes[index];
        secondNode = nodes[targetIndex];
        parent = $(firstNode).commonParent(secondNode);
        if (!parent) {
          continue;
        }
        hasGroup = false;
        for (k = 0, len = groups.length; k < len; k++) {
          group = groups[k];
          if (group.container === parent) {
            hasGroup = true;
            if (indexOf.call(group.children, firstNode) < 0) {
              group.children.push;
            }
            if (indexOf.call(group.children, secondNode) < 0) {
              group.children.push(secondNode);
            }
            break;
          }
        }
        if (!hasGroup) {
          groups.push({
            container: parent,
            children: [firstNode, secondNode]
          });
        }
      }
    }
    for (l = 0, len1 = groups.length; l < len1; l++) {
      group = groups[l];
      evaluateGroup(group, sample);
    }
    groups.sort(function(b, a) {
      return a.value - b.value;
    });
    return groups;
  };

  evaluateGroup = function(group, sample) {
    var alignFactor, child, childLevel, countValue, horizentalAlign, i, len, levelFactor, masterLevel, matchedCountValue, rect, ref, ref1, ref2, structureSample, verticalAlign;
    alignFactor = 1;
    countValue = 0;
    levelFactor = 1;
    matchedCountValue = 0;
    masterLevel = $(group.container).charactor().level;
    childLevel = $(group.children[0]).charactor().level;
    levelFactor *= Math.sqrt(1 / (childLevel - masterLevel + 1));
    countValue += group.children.length;
    verticalAlign = [];
    horizentalAlign = [];
    structureSample = $(sample).charactor().structureSample;
    ref = group.children;
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      rect = child.getBoundingClientRect();
      if (ref1 = rect.top, indexOf.call(verticalAlign, ref1) < 0) {
        verticalAlign.push(rect.top);
      }
      if (ref2 = rect.left, indexOf.call(horizentalAlign, ref2) < 0) {
        horizentalAlign.push(rect.left);
      }
      if ($(child).charactor().structureSample === structureSample) {
        matchedCountValue++;
      }
    }
    alignFactor *= 1 / Math.min(verticalAlign.length, horizentalAlign.length);
    group.value = (countValue + 10 * matchedCountValue) * alignFactor * levelFactor;
    return group.raw = [countValue, matchedCountValue, alignFactor, levelFactor];
  };

  $.fn.markAsActive = function() {
    return this.addClass("analyze-active");
  };

  $.fn.markAsInactive = function() {
    return this.removeClass("analyze-active");
  };

  $.fn.markAsSelect = function() {
    return this.addClass("analyze-select");
  };

  $.fn.markAsInselect = function() {
    return this.removeClass("analyze-select");
  };

  $.fn.markAsGroup = function(index) {
    this.addClass("analyze-group");
    return this.css({
      "box-shadow": "0 0 5px 5px yellow"
    });
  };

  $.fn.markAsIngroup = function() {
    return this.removeClass("analyze-group");
  };

  $.fn.charactor = function() {
    var i, innerStructureSample, item, len, level, node, ref;
    if (this[0].charactor) {
      return this[0].charactor;
    }
    level = 0;
    node = this[0];
    while (node) {
      level++;
      node = node.parentElement;
    }
    innerStructureSample = [];
    ref = this[0].children;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      innerStructureSample.push(item.tagName || "TEXT");
    }
    this[0].charactor = {
      level: level,
      type: this[0].tagName,
      structureSample: innerStructureSample.join(",")
    };
    return this[0].charactor;
  };

  $.fn.commonParent = function(node) {
    var i, item, len, origin, originParents, target, targetParents;
    origin = this[0];
    target = node;
    originParents = [];
    targetParents = [];
    while (origin.parentElement) {
      originParents.push(origin.parentElement);
      origin = origin.parentElement;
    }
    while (target.parentElement) {
      targetParents.push(target.parentElement);
      target = target.parentElement;
    }
    for (i = 0, len = originParents.length; i < len; i++) {
      item = originParents[i];
      if (indexOf.call(targetParents, item) >= 0) {
        return item;
      }
    }
    return null;
  };

  window.extractGroupCharactor = extractGroupCharactor;

}).call(this);
